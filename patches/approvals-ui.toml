# =============================================================================
# APPROVALS UI PATCHES - 5-Preset System with Ctrl+A Cycling
# =============================================================================
#
# This patch adds a simplified approval preset system with 5 distinct modes:
# 1. Read Only    - Can read files/code. No edits, no commands.
# 2. Plan Only    - Can read and plan. No execution.
# 3. Delegate Only - Spawns subagents for tasks. Asks before direct execution.
# 4. Workspace Only - Auto-approves sandboxed workspace commands.
# 5. YOLO         - No restrictions. Full system access.
#
# Each preset has a unique (approval, sandbox) combination for reliable detection.
#
# Keybind: Ctrl+A cycles through all 5 presets
#
# Version: Targets Codex rust-v0.92.0 and later
# =============================================================================

[meta]
name = "approvals-ui-5-preset"
description = "5-preset approval system with Ctrl+A cycling and pattern-matched detection"
version_range = ">=0.92.0"
workspace_relative = true

# =============================================================================
# Patch 1: Define 5 Distinct Approval Presets
# =============================================================================
# Each preset has a unique (approval, sandbox) combination:
# - Read Only:      (OnRequest, ReadOnly)
# - Plan Only:      (UnlessTrusted, ReadOnly)
# - Delegate Only:  (OnRequest, WorkspaceWrite)
# - Workspace Only: (OnFailure, WorkspaceWrite)
# - YOLO:           (Never, DangerFullAccess)

[[patches]]
id = "define-5-approval-presets"
file = "utils/approval-presets/src/lib.rs"

[patches.query]
type = "ast-grep"
pattern = '''
pub fn builtin_approval_presets() -> Vec<ApprovalPreset> {
    $$$
}
'''

[patches.operation]
type = "replace"
text = '''
pub fn builtin_approval_presets() -> Vec<ApprovalPreset> {
    vec![
        ApprovalPreset {
            id: "read-only",
            label: "Read Only",
            description: "Can read files and code. No edits, no commands.",
            approval: AskForApproval::OnRequest,
            sandbox: SandboxPolicy::new_read_only_policy(),
        },
        ApprovalPreset {
            id: "plan-only",
            label: "Plan Only",
            description: "Can read and plan. No execution.",
            approval: AskForApproval::UnlessTrusted,
            sandbox: SandboxPolicy::new_read_only_policy(),
        },
        ApprovalPreset {
            id: "delegate-only",
            label: "Delegate Only",
            description: "Spawns subagents for tasks. Asks before direct execution.",
            approval: AskForApproval::OnRequest,
            sandbox: SandboxPolicy::new_workspace_write_policy(),
        },
        ApprovalPreset {
            id: "workspace-only",
            label: "Workspace Only",
            description: "Auto-approves sandboxed workspace commands.",
            approval: AskForApproval::OnFailure,
            sandbox: SandboxPolicy::new_workspace_write_policy(),
        },
        ApprovalPreset {
            id: "yolo",
            label: "YOLO",
            description: "No restrictions. Full system access.",
            approval: AskForApproval::Never,
            sandbox: SandboxPolicy::DangerFullAccess,
        },
    ]
}
'''

# =============================================================================
# Patch 2: Add Ctrl+A keybind to app.rs
# =============================================================================

[[patches]]
id = "add-ctrl-a-keybind"
file = "tui/src/app.rs"

[patches.query]
type = "text"
search = '''
            KeyEvent {
                code: KeyCode::Char('t'),
                modifiers: crossterm::event::KeyModifiers::CONTROL,
                kind: KeyEventKind::Press,
                ..
            } => {
                // Enter alternate screen and set viewport to full size.
                let _ = tui.enter_alt_screen();
                self.overlay = Some(Overlay::new_transcript(self.transcript_cells.clone()));
                tui.frame_requester().schedule_frame();
            }
            KeyEvent {
                code: KeyCode::Char('g'),
'''

[patches.operation]
type = "replace"
text = '''
            KeyEvent {
                code: KeyCode::Char('t'),
                modifiers: crossterm::event::KeyModifiers::CONTROL,
                kind: KeyEventKind::Press,
                ..
            } => {
                // Enter alternate screen and set viewport to full size.
                let _ = tui.enter_alt_screen();
                self.overlay = Some(Overlay::new_transcript(self.transcript_cells.clone()));
                tui.frame_requester().schedule_frame();
            }
            // PATCH: Ctrl+A cycles approval presets
            KeyEvent {
                code: KeyCode::Char('a'),
                modifiers: crossterm::event::KeyModifiers::CONTROL,
                kind: KeyEventKind::Press,
                ..
            } => {
                self.chat_widget.cycle_approval_preset();
            }
            KeyEvent {
                code: KeyCode::Char('g'),
'''

# =============================================================================
# Patch 3: Add cycle_approval_preset method to ChatWidget
# =============================================================================

[[patches]]
id = "add-cycle-approval-method"
file = "tui/src/chatwidget.rs"

[patches.query]
type = "text"
search = '''
    fn set_skills(&mut self, skills: Option<Vec<SkillMetadata>>) {
        self.bottom_pane.set_skills(skills);
    }

    pub(crate) fn open_feedback_note('''

[patches.operation]
type = "replace"
text = '''
    fn set_skills(&mut self, skills: Option<Vec<SkillMetadata>>) {
        self.bottom_pane.set_skills(skills);
    }

    /// Cycle through approval presets with Ctrl+A
    ///
    /// Uses pattern matching to compare sandbox policies, since WorkspaceWrite
    /// variants have internal fields (writable_roots, etc.) that differ at runtime.
    pub(crate) fn cycle_approval_preset(&mut self) {
        use codex_utils_approval_presets::{builtin_approval_presets, ApprovalPreset};

        if self.bottom_pane.is_task_running() {
            self.add_info_message(
                "Cannot change approval mode while a task is running.".to_string(),
                Some("Wait for the task to finish, or interrupt it.".to_string()),
            );
            return;
        }

        const CYCLE_IDS: [&str; 5] = ["read-only", "plan-only", "delegate-only", "workspace-only", "yolo"];
        let presets = builtin_approval_presets();
        let cycle_presets: Vec<ApprovalPreset> = CYCLE_IDS
            .iter()
            .filter_map(|id| presets.iter().find(|p| p.id == *id).cloned())
            .collect();

        if cycle_presets.is_empty() {
            return;
        }

        let current_approval = self.config.permissions.approval_policy.value();
        let current_sandbox = self.config.permissions.sandbox_policy.get();

        // Use pattern matching for sandbox comparison - WorkspaceWrite has internal
        // fields that differ at runtime (writable_roots, etc.), so direct equality fails
        let current_idx = cycle_presets.iter().position(|preset| {
            Self::preset_matches_current(current_approval, current_sandbox, preset)
        });

        let next_idx = current_idx.map_or(0, |idx| (idx + 1) % cycle_presets.len());
        let next = cycle_presets[next_idx].clone();

        // Warn before enabling YOLO mode
        if next.id == "yolo"
            && !self.config.notices.hide_full_access_warning.unwrap_or(false)
        {
            self.open_full_access_confirmation(next, false);
            return;
        }

        self.app_event_tx.send(AppEvent::CodexOp(Op::OverrideTurnContext {
            cwd: None,
            approval_policy: Some(next.approval),
            sandbox_policy: Some(next.sandbox.clone()),
            windows_sandbox_level: None,
            model: None,
            effort: None,
            summary: None,
            collaboration_mode: None,
            personality: None,
        }));

        self.add_info_message(
            format!("Approval mode: {}", next.label),
            Some(next.description.to_string()),
        );
    }

    pub(crate) fn open_feedback_note('''
