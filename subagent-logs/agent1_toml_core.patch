diff --git a/src/toml/errors.rs b/src/toml/errors.rs
new file mode 100644
index 0000000..f0c20bd
--- /dev/null
+++ b/src/toml/errors.rs
@@ -0,0 +1,70 @@
+use std::ops::Range;
+use thiserror::Error;
+
+/// TOML query and parsing errors.
+#[derive(Error, Debug, Clone, PartialEq, Eq)]
+pub enum TomlError {
+    #[error("Invalid TOML syntax: {message}")]
+    InvalidTomlSyntax {
+        message: String,
+        span: Option<Range<usize>>,
+    },
+
+    #[error("Section not found: {path}")]
+    SectionNotFound { path: String },
+
+    #[error("Key not found: {key} (section: {section})")]
+    KeyNotFound { section: String, key: String },
+
+    #[error("Ambiguous match for {path} ({matches} matches)")]
+    AmbiguousMatch { path: String, matches: usize },
+}
+
+impl TomlError {
+    pub fn invalid_syntax(message: impl Into<String>, span: Option<Range<usize>>) -> Self {
+        Self::InvalidTomlSyntax {
+            message: message.into(),
+            span,
+        }
+    }
+
+    pub fn section_not_found(path: impl Into<String>) -> Self {
+        Self::SectionNotFound { path: path.into() }
+    }
+
+    pub fn key_not_found(section: impl Into<String>, key: impl Into<String>) -> Self {
+        Self::KeyNotFound {
+            section: section.into(),
+            key: key.into(),
+        }
+    }
+
+    pub fn ambiguous_match(path: impl Into<String>, matches: usize) -> Self {
+        Self::AmbiguousMatch {
+            path: path.into(),
+            matches,
+        }
+    }
+}
+
+impl From<toml_edit::TomlError> for TomlError {
+    fn from(err: toml_edit::TomlError) -> Self {
+        Self::InvalidTomlSyntax {
+            message: err.to_string(),
+            span: err.span(),
+        }
+    }
+}

diff --git a/src/toml/query.rs b/src/toml/query.rs
new file mode 100644
index 0000000..c5747f9
--- /dev/null
+++ b/src/toml/query.rs
@@ -0,0 +1,298 @@
+use std::fmt;
+use std::str::FromStr;
+
+use toml_edit::{DocumentMut, Item, Key, Table};
+
+use super::errors::TomlError;
+
+/// A dotted path that identifies a TOML section (table or array-of-tables).
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+pub struct SectionPath {
+    segments: Vec<String>,
+    raw: Option<String>,
+}
+
+impl SectionPath {
+    /// Parse a dotted section path using TOML key syntax.
+    pub fn parse(input: &str) -> Result<Self, TomlError> {
+        let segments = parse_dotted_path(input)?;
+        Ok(Self {
+            segments,
+            raw: Some(input.to_string()),
+        })
+    }
+
+    /// Create a section path from pre-split segments.
+    pub fn from_segments<I, S>(segments: I) -> Result<Self, TomlError>
+    where
+        I: IntoIterator<Item = S>,
+        S: Into<String>,
+    {
+        let segments: Vec<String> = segments.into_iter().map(Into::into).collect();
+        validate_segments(&segments)?;
+        Ok(Self { segments, raw: None })
+    }
+
+    /// Borrow the path segments.
+    pub fn segments(&self) -> &[String] {
+        &self.segments
+    }
+}
+
+impl fmt::Display for SectionPath {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        if let Some(raw) = &self.raw {
+            return f.write_str(raw);
+        }
+        f.write_str(&self.segments.join("."))
+    }
+}
+
+impl FromStr for SectionPath {
+    type Err = TomlError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        SectionPath::parse(s)
+    }
+}
+
+/// A dotted path that identifies a key within a section.
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+pub struct KeyPath {
+    inner: SectionPath,
+}
+
+impl KeyPath {
+    /// Parse a dotted key path using TOML key syntax.
+    pub fn parse(input: &str) -> Result<Self, TomlError> {
+        SectionPath::parse(input).map(|inner| Self { inner })
+    }
+
+    /// Create a key path from pre-split segments.
+    pub fn from_segments<I, S>(segments: I) -> Result<Self, TomlError>
+    where
+        I: IntoIterator<Item = S>,
+        S: Into<String>,
+    {
+        SectionPath::from_segments(segments).map(|inner| Self { inner })
+    }
+
+    /// Borrow the path segments.
+    pub fn segments(&self) -> &[String] {
+        self.inner.segments()
+    }
+}
+
+impl fmt::Display for KeyPath {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        fmt::Display::fmt(&self.inner, f)
+    }
+}
+
+impl FromStr for KeyPath {
+    type Err = TomlError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        KeyPath::parse(s)
+    }
+}
+
+impl From<SectionPath> for KeyPath {
+    fn from(inner: SectionPath) -> Self {
+        Self { inner }
+    }
+}
+
+/// A parsed TOML query targeting either a section or a key.
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum TomlQuery {
+    Section(SectionQuery),
+    Key(KeyQuery),
+}
+
+/// Query that targets a section by path.
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct SectionQuery {
+    pub path: SectionPath,
+}
+
+impl SectionQuery {
+    pub fn new(path: SectionPath) -> Self {
+        Self { path }
+    }
+
+    /// Resolve the section to a table reference.
+    pub fn resolve<'a>(&self, doc: &'a DocumentMut) -> Result<&'a Table, TomlError> {
+        resolve_table(doc.as_table(), &self.path)
+    }
+
+    /// Resolve the section to a mutable table reference.
+    pub fn resolve_mut<'a>(&self, doc: &'a mut DocumentMut) -> Result<&'a mut Table, TomlError> {
+        resolve_table_mut(doc.as_table_mut(), &self.path)
+    }
+}
+
+/// Query that targets a key within a section.
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct KeyQuery {
+    pub section: SectionPath,
+    pub key: KeyPath,
+}
+
+impl KeyQuery {
+    pub fn new(section: SectionPath, key: KeyPath) -> Self {
+        Self { section, key }
+    }
+
+    /// Resolve the key to an item reference.
+    pub fn resolve<'a>(&self, doc: &'a DocumentMut) -> Result<&'a Item, TomlError> {
+        let table = resolve_table(doc.as_table(), &self.section)?;
+        resolve_key_in_table(table, &self.section, &self.key)
+    }
+
+    /// Resolve the key to a mutable item reference.
+    pub fn resolve_mut<'a>(&self, doc: &'a mut DocumentMut) -> Result<&'a mut Item, TomlError> {
+        let table = resolve_table_mut(doc.as_table_mut(), &self.section)?;
+        resolve_key_in_table_mut(table, &self.section, &self.key)
+    }
+}
+
+/// Parse a TOML document into a mutable representation.
+pub fn parse_document(input: &str) -> Result<DocumentMut, TomlError> {
+    DocumentMut::from_str(input).map_err(TomlError::from)
+}
+
+/// Return the span for a matched item, if available.
+pub fn item_span(item: &Item) -> Option<std::ops::Range<usize>> {
+    match item {
+        Item::None => None,
+        Item::Value(value) => value.span(),
+        Item::Table(table) => table.span(),
+        Item::ArrayOfTables(array) => array.span(),
+    }
+}
+
+fn resolve_table<'a>(root: &'a Table, path: &SectionPath) -> Result<&'a Table, TomlError> {
+    let mut current = root;
+    for segment in path.segments() {
+        let item = current
+            .get(segment.as_str())
+            .ok_or_else(|| TomlError::section_not_found(path.to_string()))?;
+        match item {
+            Item::Table(table) => {
+                current = table;
+            }
+            Item::ArrayOfTables(array) => {
+                let len = array.len();
+                if len == 0 {
+                    return Err(TomlError::section_not_found(path.to_string()));
+                }
+                if len > 1 {
+                    return Err(TomlError::ambiguous_match(path.to_string(), len));
+                }
+                current = array
+                    .get(0)
+                    .ok_or_else(|| TomlError::section_not_found(path.to_string()))?;
+            }
+            _ => {
+                return Err(TomlError::section_not_found(path.to_string()));
+            }
+        }
+    }
+    Ok(current)
+}
+
+fn resolve_table_mut<'a>(
+    root: &'a mut Table,
+    path: &SectionPath,
+) -> Result<&'a mut Table, TomlError> {
+    resolve_table_mut_inner(root, path.segments(), path)
+}
+
+fn resolve_table_mut_inner<'a>(
+    table: &'a mut Table,
+    segments: &[String],
+    full_path: &SectionPath,
+) -> Result<&'a mut Table, TomlError> {
+    if segments.is_empty() {
+        return Ok(table);
+    }
+
+    let key = &segments[0];
+    let item = table
+        .get_mut(key.as_str())
+        .ok_or_else(|| TomlError::section_not_found(full_path.to_string()))?;
+
+    match item {
+        Item::Table(next) => resolve_table_mut_inner(next, &segments[1..], full_path),
+        Item::ArrayOfTables(array) => {
+            let len = array.len();
+            if len == 0 {
+                return Err(TomlError::section_not_found(full_path.to_string()));
+            }
+            if len > 1 {
+                return Err(TomlError::ambiguous_match(full_path.to_string(), len));
+            }
+            let next = array
+                .get_mut(0)
+                .ok_or_else(|| TomlError::section_not_found(full_path.to_string()))?;
+            resolve_table_mut_inner(next, &segments[1..], full_path)
+        }
+        _ => Err(TomlError::section_not_found(full_path.to_string())),
+    }
+}
+
+fn resolve_key_in_table<'a>(
+    table: &'a Table,
+    section: &SectionPath,
+    key: &KeyPath,
+) -> Result<&'a Item, TomlError> {
+    let mut current = table;
+    let segments = key.segments();
+    let full_path = join_paths(section, key);
+
+    for (index, segment) in segments.iter().enumerate() {
+        let is_last = index + 1 == segments.len();
+        let item = current
+            .get(segment.as_str())
+            .ok_or_else(|| TomlError::key_not_found(section.to_string(), key.to_string()))?;
+        if is_last {
+            return Ok(item);
+        }
+
+        match item {
+            Item::Table(next) => {
+                current = next;
+            }
+            Item::ArrayOfTables(array) => {
+                let len = array.len();
+                if len == 0 {
+                    return Err(TomlError::key_not_found(section.to_string(), key.to_string()));
+                }
+                if len > 1 {
+                    return Err(TomlError::ambiguous_match(full_path, len));
+                }
+                current = array
+                    .get(0)
+                    .ok_or_else(|| TomlError::key_not_found(section.to_string(), key.to_string()))?;
+            }
+            _ => {
+                return Err(TomlError::key_not_found(section.to_string(), key.to_string()));
+            }
+        }
+    }
+
+    Err(TomlError::key_not_found(
+        section.to_string(),
+        key.to_string(),
+    ))
+}
+
+fn resolve_key_in_table_mut<'a>(
+    table: &'a mut Table,
+    section: &SectionPath,
+    key: &KeyPath,
+) -> Result<&'a mut Item, TomlError> {
+    resolve_key_in_table_mut_inner(table, key.segments(), section, key)
+}
+
+fn resolve_key_in_table_mut_inner<'a>(
+    table: &'a mut Table,
+    segments: &[String],
+    section: &SectionPath,
+    key: &KeyPath,
+) -> Result<&'a mut Item, TomlError> {
+    if segments.is_empty() {
+        return Err(TomlError::key_not_found(
+            section.to_string(),
+            key.to_string(),
+        ));
+    }
+
+    let segment = &segments[0];
+    let item = table
+        .get_mut(segment.as_str())
+        .ok_or_else(|| TomlError::key_not_found(section.to_string(), key.to_string()))?;
+
+    if segments.len() == 1 {
+        return Ok(item);
+    }
+
+    let full_path = join_paths(section, key);
+    match item {
+        Item::Table(next) => resolve_key_in_table_mut_inner(next, &segments[1..], section, key),
+        Item::ArrayOfTables(array) => {
+            let len = array.len();
+            if len == 0 {
+                return Err(TomlError::key_not_found(section.to_string(), key.to_string()));
+            }
+            if len > 1 {
+                return Err(TomlError::ambiguous_match(full_path, len));
+            }
+            let next = array
+                .get_mut(0)
+                .ok_or_else(|| TomlError::key_not_found(section.to_string(), key.to_string()))?;
+            resolve_key_in_table_mut_inner(next, &segments[1..], section, key)
+        }
+        _ => Err(TomlError::key_not_found(section.to_string(), key.to_string())),
+    }
+}
+
+fn parse_dotted_path(input: &str) -> Result<Vec<String>, TomlError> {
+    let keys = Key::parse(input).map_err(TomlError::from)?;
+    let segments: Vec<String> = keys.into_iter().map(|key| key.get().to_string()).collect();
+    validate_segments(&segments)?;
+    Ok(segments)
+}
+
+fn validate_segments(segments: &[String]) -> Result<(), TomlError> {
+    if segments.is_empty() {
+        return Err(TomlError::invalid_syntax("empty dotted path", None));
+    }
+    if segments.iter().any(|segment| segment.is_empty()) {
+        return Err(TomlError::invalid_syntax("empty path segment", None));
+    }
+    Ok(())
+}
+
+fn join_paths(section: &SectionPath, key: &KeyPath) -> String {
+    if section.segments().is_empty() {
+        key.to_string()
+    } else {
+        format!("{}.{}", section, key)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn parse_section_path_handles_quoted_segments() {
+        let path = SectionPath::parse("package.\"docs.rs\"").expect("valid path");
+        assert_eq!(path.segments(), &["package", "docs.rs"]);
+    }
+
+    #[test]
+    fn parse_key_path_rejects_empty() {
+        let err = KeyPath::parse("").expect_err("empty key path");
+        assert!(matches!(err, TomlError::InvalidTomlSyntax { .. }));
+    }
+}

diff --git a/src/toml/mod.rs b/src/toml/mod.rs
new file mode 100644
index 0000000..7e21c7e
--- /dev/null
+++ b/src/toml/mod.rs
@@ -0,0 +1,15 @@
+//! TOML query infrastructure for structure-preserving edits.
+
+pub mod errors;
+pub mod query;
+
+pub use errors::TomlError;
+pub use query::{
+    item_span, parse_document, KeyPath, KeyQuery, SectionPath, SectionQuery, TomlQuery,
+};
