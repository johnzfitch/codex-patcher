diff --git a/src/config/mod.rs b/src/config/mod.rs
new file mode 100644
index 0000000..2a4b7b2
--- /dev/null
+++ b/src/config/mod.rs
@@
+pub mod loader;
+pub mod schema;
+
+pub use loader::{load_from_path, load_from_str, ConfigError};
+pub use schema::{
+    Constraints, HashAlgorithm, Metadata, Operation, PatchConfig, PatchDefinition, Positioning,
+    Query, RelativePosition, ValidationError, ValidationIssue, Verify,
+};
diff --git a/src/config/loader.rs b/src/config/loader.rs
new file mode 100644
index 0000000..e8f57a3
--- /dev/null
+++ b/src/config/loader.rs
@@
+use crate::config::schema::{PatchConfig, ValidationError};
+use std::fmt;
+use std::fs;
+use std::path::{Path, PathBuf};
+
+#[derive(Debug)]
+pub enum ConfigError {
+    Io { path: PathBuf, source: std::io::Error },
+    Toml {
+        path: Option<PathBuf>,
+        source: toml_edit::de::Error,
+    },
+    Validation {
+        path: Option<PathBuf>,
+        source: ValidationError,
+    },
+}
+
+impl ConfigError {
+    fn with_path(self, path: &Path) -> Self {
+        let path = path.to_path_buf();
+        match self {
+            ConfigError::Io { .. } => self,
+            ConfigError::Toml { path: None, source } => ConfigError::Toml {
+                path: Some(path),
+                source,
+            },
+            ConfigError::Validation { path: None, source } => ConfigError::Validation {
+                path: Some(path),
+                source,
+            },
+            other => other,
+        }
+    }
+}
+
+impl fmt::Display for ConfigError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            ConfigError::Io { path, source } => {
+                write!(f, "failed to read patch config from {}: {}", path.display(), source)
+            }
+            ConfigError::Toml { path, source } => match path {
+                Some(path) => write!(
+                    f,
+                    "failed to parse patch config TOML ({}): {}",
+                    path.display(),
+                    source
+                ),
+                None => write!(f, "failed to parse patch config TOML: {}", source),
+            },
+            ConfigError::Validation { path, source } => match path {
+                Some(path) => write!(
+                    f,
+                    "invalid patch config ({}): {}",
+                    path.display(),
+                    source
+                ),
+                None => write!(f, "invalid patch config: {}", source),
+            },
+        }
+    }
+}
+
+impl std::error::Error for ConfigError {
+    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
+        match self {
+            ConfigError::Io { source, .. } => Some(source),
+            ConfigError::Toml { source, .. } => Some(source),
+            ConfigError::Validation { source, .. } => Some(source),
+        }
+    }
+}
+
+pub fn load_from_str(input: &str) -> Result<PatchConfig, ConfigError> {
+    let config: PatchConfig =
+        toml_edit::de::from_str(input).map_err(|source| ConfigError::Toml {
+            path: None,
+            source,
+        })?;
+    config
+        .validate()
+        .map_err(|source| ConfigError::Validation { path: None, source })?;
+    Ok(config)
+}
+
+pub fn load_from_path(path: impl AsRef<Path>) -> Result<PatchConfig, ConfigError> {
+    let path = path.as_ref();
+    let contents = fs::read_to_string(path).map_err(|source| ConfigError::Io {
+        path: path.to_path_buf(),
+        source,
+    })?;
+    load_from_str(&contents).map_err(|error| error.with_path(path))
+}
+diff --git a/src/config/schema.rs b/src/config/schema.rs
+new file mode 100644
+index 0000000..670a7aa
+--- /dev/null
++++ b/src/config/schema.rs
+@@
++use serde::Deserialize;
++use std::collections::HashSet;
++use std::error::Error;
++use std::fmt;
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(deny_unknown_fields)]
++pub struct PatchConfig {
++    #[serde(default)]
++    pub patches: Vec<PatchDefinition>,
++}
++
++impl PatchConfig {
++    pub fn validate(&self) -> Result<(), ValidationError> {
++        let mut issues = Vec::new();
++
++        if self.patches.is_empty() {
++            issues.push(ValidationIssue::global(
++                "patches",
++                "at least one patch definition is required",
++            ));
++        }
++
++        let mut seen = HashSet::new();
++        for (index, patch) in self.patches.iter().enumerate() {
++            patch.validate(index, &mut issues);
++            let id = patch.id.trim();
++            if !id.is_empty() {
++                if !seen.insert(id.to_string()) {
++                    issues.push(ValidationIssue::for_patch(
++                        id,
++                        "id",
++                        "duplicate patch id",
++                    ));
++                }
++            }
++        }
++
++        if issues.is_empty() {
++            Ok(())
++        } else {
++            Err(ValidationError { issues })
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(deny_unknown_fields)]
++pub struct PatchDefinition {
++    pub id: String,
++    #[serde(default)]
++    pub description: Option<String>,
++    pub query: Query,
++    pub operation: Operation,
++    #[serde(default)]
++    pub verify: Option<Verify>,
++    #[serde(default)]
++    pub metadata: Option<Metadata>,
++    #[serde(default)]
++    pub positioning: Option<Positioning>,
++    #[serde(default)]
++    pub constraints: Option<Constraints>,
++}
++
++impl PatchDefinition {
++    fn validate(&self, index: usize, issues: &mut Vec<ValidationIssue>) {
++        let id = self.id.trim();
++        let patch_id = if id.is_empty() {
++            issues.push(ValidationIssue::at_index(
++                index,
++                "id",
++                "patch id must be non-empty",
++            ));
++            None
++        } else {
++            Some(id)
++        };
++
++        self.query.validate(index, patch_id, issues);
++        self.operation.validate(index, patch_id, issues);
++
++        if let Some(verify) = &self.verify {
++            verify.validate(index, patch_id, issues);
++        }
++        if let Some(metadata) = &self.metadata {
++            metadata.validate(index, patch_id, issues);
++        }
++        if let Some(positioning) = &self.positioning {
++            positioning.validate(index, patch_id, issues);
++        }
++        if let Some(constraints) = &self.constraints {
++            constraints.validate(index, patch_id, issues);
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(tag = "kind", rename_all = "snake_case", deny_unknown_fields)]
++pub enum Query {
++    ExactSpan {
++        file: String,
++        byte_start: usize,
++        byte_end: usize,
++    },
++    Text {
++        file: String,
++        pattern: String,
++    },
++    TreeSitter {
++        file: String,
++        query: String,
++        #[serde(default)]
++        capture: Option<String>,
++    },
++    TomlPath {
++        file: String,
++        path: Vec<String>,
++    },
++}
++
++impl Query {
++    fn validate(&self, index: usize, patch_id: Option<&str>, issues: &mut Vec<ValidationIssue>) {
++        match self {
++            Query::ExactSpan {
++                file,
++                byte_start,
++                byte_end,
++            } => {
++                validate_non_empty(index, patch_id, issues, "query.file", file);
++                if byte_start >= byte_end {
++                    issues.push(ValidationIssue::for_context(
++                        index,
++                        patch_id,
++                        "query",
++                        "byte_start must be less than byte_end",
++                    ));
++                }
++            }
++            Query::Text { file, pattern } => {
++                validate_non_empty(index, patch_id, issues, "query.file", file);
++                validate_non_empty(index, patch_id, issues, "query.pattern", pattern);
++            }
++            Query::TreeSitter { file, query, .. } => {
++                validate_non_empty(index, patch_id, issues, "query.file", file);
++                validate_non_empty(index, patch_id, issues, "query.query", query);
++            }
++            Query::TomlPath { file, path } => {
++                validate_non_empty(index, patch_id, issues, "query.file", file);
++                if path.is_empty() {
++                    issues.push(ValidationIssue::for_context(
++                        index,
++                        patch_id,
++                        "query.path",
++                        "path must include at least one segment",
++                    ));
++                }
++                for segment in path {
++                    if segment.trim().is_empty() {
++                        issues.push(ValidationIssue::for_context(
++                            index,
++                            patch_id,
++                            "query.path",
++                            "path segments must be non-empty",
++                        ));
++                        break;
++                    }
++                }
++            }
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(tag = "kind", rename_all = "snake_case", deny_unknown_fields)]
++pub enum Operation {
++    Replace { text: String },
++    Insert { text: String },
++    Append { text: String },
++    Delete,
++}
++
++impl Operation {
++    fn validate(&self, index: usize, patch_id: Option<&str>, issues: &mut Vec<ValidationIssue>) {
++        match self {
++            Operation::Replace { text }
++            | Operation::Insert { text }
++            | Operation::Append { text } => {
++                if text.is_empty() {
++                    issues.push(ValidationIssue::for_context(
++                        index,
++                        patch_id,
++                        "operation.text",
++                        "text must be non-empty",
++                    ));
++                }
++            }
++            Operation::Delete => {}
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(deny_unknown_fields)]
++pub struct Verify {
++    #[serde(default)]
++    pub expected: Option<String>,
++    #[serde(default)]
++    pub hash: Option<String>,
++    #[serde(default)]
++    pub hash_algorithm: Option<HashAlgorithm>,
++}
++
++impl Verify {
++    fn validate(&self, index: usize, patch_id: Option<&str>, issues: &mut Vec<ValidationIssue>) {
++        if self.expected.as_ref().map_or(true, |value| value.is_empty())
++            && self.hash.as_ref().map_or(true, |value| value.is_empty())
++        {
++            issues.push(ValidationIssue::for_context(
++                index,
++                patch_id,
++                "verify",
++                "expected or hash must be provided",
++            ));
++        }
++        if self.hash_algorithm.is_some() && self.hash.as_ref().map_or(true, |v| v.is_empty()) {
++            issues.push(ValidationIssue::for_context(
++                index,
++                patch_id,
++                "verify.hash_algorithm",
++                "hash_algorithm requires a non-empty hash",
++            ));
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(rename_all = "snake_case")]
++pub enum HashAlgorithm {
++    Xxh3,
++    Sha256,
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(deny_unknown_fields)]
++pub struct Metadata {
++    #[serde(default)]
++    pub title: Option<String>,
++    #[serde(default)]
++    pub description: Option<String>,
++    #[serde(default)]
++    pub author: Option<String>,
++    #[serde(default)]
++    pub tags: Vec<String>,
++    #[serde(default)]
++    pub source: Option<String>,
++    #[serde(default)]
++    pub references: Vec<String>,
++}
++
++impl Metadata {
++    fn validate(&self, index: usize, patch_id: Option<&str>, issues: &mut Vec<ValidationIssue>) {
++        for tag in &self.tags {
++            if tag.trim().is_empty() {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "metadata.tags",
++                    "tags must be non-empty",
++                ));
++                break;
++            }
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(deny_unknown_fields)]
++pub struct Positioning {
++    #[serde(default)]
++    pub anchor: Option<String>,
++    #[serde(default)]
++    pub relative: Option<RelativePosition>,
++    #[serde(default)]
++    pub index: Option<usize>,
++}
++
++impl Positioning {
++    fn validate(&self, index: usize, patch_id: Option<&str>, issues: &mut Vec<ValidationIssue>) {
++        if let Some(anchor) = &self.anchor {
++            if anchor.trim().is_empty() {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "positioning.anchor",
++                    "anchor must be non-empty",
++                ));
++            }
++        }
++
++        if self.anchor.is_some() && self.index.is_some() {
++            issues.push(ValidationIssue::for_context(
++                index,
++                patch_id,
++                "positioning",
++                "anchor and index cannot both be set",
++            ));
++        }
++
++        if self.anchor.is_none() && self.index.is_none() {
++            issues.push(ValidationIssue::for_context(
++                index,
++                patch_id,
++                "positioning",
++                "anchor or index must be provided",
++            ));
++        }
++    }
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(rename_all = "snake_case")]
++pub enum RelativePosition {
++    Before,
++    After,
++}
++
++#[derive(Debug, Clone, Deserialize)]
++#[serde(deny_unknown_fields)]
++pub struct Constraints {
++    #[serde(default)]
++    pub min_version: Option<String>,
++    #[serde(default)]
++    pub max_version: Option<String>,
++    #[serde(default)]
++    pub version_req: Option<String>,
++    #[serde(default)]
++    pub editions: Vec<String>,
++    #[serde(default)]
++    pub targets: Vec<String>,
++    #[serde(default)]
++    pub features: Vec<String>,
++}
++
++impl Constraints {
++    fn validate(&self, index: usize, patch_id: Option<&str>, issues: &mut Vec<ValidationIssue>) {
++        let min_version = match &self.min_version {
++            Some(value) if value.trim().is_empty() => {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.min_version",
++                    "min_version must be non-empty",
++                ));
++                None
++            }
++            Some(value) => match semver::Version::parse(value) {
++                Ok(parsed) => Some(parsed),
++                Err(_) => {
++                    issues.push(ValidationIssue::for_context(
++                        index,
++                        patch_id,
++                        "constraints.min_version",
++                        "min_version must be a valid semver version",
++                    ));
++                    None
++                }
++            },
++            None => None,
++        };
++
++        let max_version = match &self.max_version {
++            Some(value) if value.trim().is_empty() => {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.max_version",
++                    "max_version must be non-empty",
++                ));
++                None
++            }
++            Some(value) => match semver::Version::parse(value) {
++                Ok(parsed) => Some(parsed),
++                Err(_) => {
++                    issues.push(ValidationIssue::for_context(
++                        index,
++                        patch_id,
++                        "constraints.max_version",
++                        "max_version must be a valid semver version",
++                    ));
++                    None
++                }
++            },
++            None => None,
++        };
++
++        if let (Some(min), Some(max)) = (&min_version, &max_version) {
++            if min > max {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints",
++                    "min_version must be less than or equal to max_version",
++                ));
++            }
++        }
++
++        if let Some(req) = &self.version_req {
++            if req.trim().is_empty() {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.version_req",
++                    "version_req must be non-empty",
++                ));
++            } else if semver::VersionReq::parse(req).is_err() {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.version_req",
++                    "version_req must be a valid semver requirement",
++                ));
++            }
++        }
++
++        for edition in &self.editions {
++            if !matches!(edition.as_str(), "2015" | "2018" | "2021" | "2024") {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.editions",
++                    "editions must be one of 2015, 2018, 2021, 2024",
++                ));
++                break;
++            }
++        }
++
++        for target in &self.targets {
++            if target.trim().is_empty() {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.targets",
++                    "targets must be non-empty",
++                ));
++                break;
++            }
++        }
++
++        for feature in &self.features {
++            if feature.trim().is_empty() {
++                issues.push(ValidationIssue::for_context(
++                    index,
++                    patch_id,
++                    "constraints.features",
++                    "features must be non-empty",
++                ));
++                break;
++            }
++        }
++    }
++}
++
++#[derive(Debug, Clone)]
++pub struct ValidationIssue {
++    pub location: String,
++    pub field: &'static str,
++    pub message: String,
++}
++
++impl ValidationIssue {
++    fn new(location: impl Into<String>, field: &'static str, message: impl Into<String>) -> Self {
++        Self {
++            location: location.into(),
++            field,
++            message: message.into(),
++        }
++    }
++
++    fn global(field: &'static str, message: impl Into<String>) -> Self {
++        Self::new("config", field, message)
++    }
++
++    fn at_index(index: usize, field: &'static str, message: impl Into<String>) -> Self {
++        Self::new(format!("patches[{index}]"), field, message)
++    }
++
++    fn for_patch(id: &str, field: &'static str, message: impl Into<String>) -> Self {
++        Self::new(format!("patches[id={id}]"), field, message)
++    }
++
++    fn for_context(
++        index: usize,
++        patch_id: Option<&str>,
++        field: &'static str,
++        message: impl Into<String>,
++    ) -> Self {
++        match patch_id {
++            Some(id) => Self::for_patch(id, field, message),
++            None => Self::at_index(index, field, message),
++        }
++    }
++}
++
++impl fmt::Display for ValidationIssue {
++    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
++        write!(f, "{}.{}: {}", self.location, self.field, self.message)
++    }
++}
++
++#[derive(Debug, Clone)]
++pub struct ValidationError {
++    pub issues: Vec<ValidationIssue>,
++}
++
++impl fmt::Display for ValidationError {
++    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
++        writeln!(f, "patch configuration validation failed:")?;
++        for issue in &self.issues {
++            writeln!(f, "- {}", issue)?;
++        }
++        Ok(())
++    }
++}
++
++impl Error for ValidationError {}
++
++fn validate_non_empty(
++    index: usize,
++    patch_id: Option<&str>,
++    issues: &mut Vec<ValidationIssue>,
++    field: &'static str,
++    value: &str,
++) {
++    if value.trim().is_empty() {
++        issues.push(ValidationIssue::for_context(
++            index,
++            patch_id,
++            field,
++            "value must be non-empty",
++        ));
++    }
++}
